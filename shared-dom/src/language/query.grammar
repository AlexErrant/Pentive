@top Program { expression* }
@skip { whitespace }
@precedence { unary @right } // https://www.ibm.com/docs/en/i/7.5?topic=operators-operator-precedence-associativity

expression[@dynamicPrecedence=0] {
  !unary Not?
  (string | Group | Label)
  ~x (Or? expression)*
}

stringExpression[@dynamicPrecedence=1] {
  !unary Not?
  string
  ~x (Or? stringExpression)*
}

idExpression[@dynamicPrecedence=2] {
  !unary Not?
  id
  ~x (Or? idExpression)*
}

stateValueExpression[@dynamicPrecedence=3] {
  !unary Not?
  stateValue
  ~x (Or? stateValueExpression)*
}

kindValueExpression[@dynamicPrecedence=3] {
  !unary Not?
  KindValue
  ~x (Or? kindValueExpression)*
}

Group { "(" expression ")" }

stateIs { kw<"state"> is }
kindIs  { kw<"kind">  is }

Label {
    "(" Not? stringLabels     stringExpression ")" | stringLabels Not? string
  | "(" Not?     idLabels         idExpression ")" |     idLabels Not? id
  | "(" Not?      stateIs stateValueExpression ")" |      stateIs Not? stateValue
  | "(" Not?       kindIs  kindValueExpression ")" |       kindIs Not?  KindValue
  | due
  | repsLapses
  | createdUpdated
  | reviewed
}

string {
  Regex |
  ( SimpleString | QuotedString | Number | Html ) Wildcard?
}

id { SimpleString | QuotedString | Number }

// "keyword"
kw<word> { @specialize[@name={word}]<SimpleString, word> }

stringLabels { 
  ( kw<"tag">
  | kw<"template">
  | kw<"setting">
  | kw<"field"> Is FieldName
  ) Is
}

FieldName {
  Not? 
  ( 
    Regex |
    ( SimpleString | QuotedString | Number ) Wildcard?
  )
}

idLabels { 
  ( kw<"templateId">
  | kw<"cardId">
  | kw<"noteId">
  | kw<"settingId">
  ) is
}

Or { @specialize<SimpleString, "OR"> | ","}

stateValue {
    kw<"normal">
  | kw<"buried">
  | kw<"userBuried">
  | kw<"schedulerBuried">
  | kw<"suspended">
}

due {
  kw<"due">
  ( is kw<"true">
  | is kw<"false">
  | is Not? Number
  | Comparison Date )
}

createdUpdated {
  (
    ( kw<"note"> | kw<"card"> ) ":"
  ) ?
  ( kw<"created"> | kw<"edited"> )
  ( is Not? Number
  | Comparison Date )
}

repsLapses {
  ( kw<"reps"> | kw<"lapses"> )
  Comparison Number
}

reviewed {
  ( kw<"reviewed"> | kw<"firstReviewed"> )
  Comparison ( Not? Number | Date )
  ( Comparison
    ( Rating
    | kw<"again">
    | kw<"hard">
    | kw<"good">
    | kw<"easy"> )
  ) ?
}

Comparison { ":" | "=" | "<" | ">" | "<=" | ">=" }
Is { ":" | "=" } // Used when we care about the difference between = and :
is { ":" | "=" } // Used when we don't care. Exists to make the grammar more forgiving for users.

@external tokens labelValue from "./query.tokens.ts" {
  KindValue
}

@context labelContext from "./query.tokens.ts"

@tokens {
  Wildcard { "*" }
  QuotedString { '"' char* '"' }
  Html         { '`' char* '`' }

  // https://github.com/lezer-parser/javascript/blob/392c6115647c9e55c147ac2d702f75be127a7b2d/src/javascript.grammar#L683
  // Not exactly the same because we're more interested in correctness (than tokenization) https://github.com/lezer-parser/javascript/pull/31#issuecomment-2016585616
  Regex[isolate] { "/" (![/\\\n[] | "\\" ![\n] | "[" (![\n\\\]] | "\\" ![\n])* "]")+ "/" $[dgimsuvy]* }

  // a char is any non-doublequote or non-backslash... or a backslash followed by a doublequote or backslash
  char {
         !["\\] |
    "\\" $["\\]
  }
  // a SimpleString is any series of characters that is not equals, less than, greater than, backtick, backslash, forwardslash, asterisk, comma, parentheses, colon, doublequote, or whitespace (as defined by the Unicode standard)
  SimpleString { ( ![=<>`\\/*,():"\u0009\u000A\u000B\u000C\u000D\u0020\u0085\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000] )+ }
  whitespace { @whitespace+ }
  Number { @digit+ }
  Date { @digit @digit @digit @digit "-" @digit? @digit "-" @digit? @digit }
  Rating { "1" | "2" | "3" | "4" }

  Not { "-" }
  @precedence { Date, Number, Not, SimpleString }
  @precedence { Rating, SimpleString }
}

@external propSource queryHighlighting from "./query.highlight.js"
