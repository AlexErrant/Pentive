@top Program { expression* }
@skip { whitespace }
@precedence { unary @right } // https://www.ibm.com/docs/en/i/7.5?topic=operators-operator-precedence-associativity

expression[@dynamicPrecedence=0] {
  !unary Not?
  (string | Group | Label)
  ~x (Or? expression)*
}

stringExpression[@dynamicPrecedence=1] {
  !unary Not?
  string
  ~x (Or? stringExpression)*
}

idExpression[@dynamicPrecedence=2] {
  !unary Not?
  id
  ~x (Or? idExpression)*
}

stateEnumExpression[@dynamicPrecedence=3] {
  !unary Not?
  StateEnum
  ~x (Or? stateEnumExpression)*
}

StateEnum {
    enum<"normal">
  | enum<"buried">
  | enum<"userBuried">
  | enum<"schedulerBuried">
  | enum<"suspended">
}

kindEnumExpression[@dynamicPrecedence=3] {
  !unary Not?
  KindEnum
  ~x (Or? kindEnumExpression)*
}

KindEnum {
    enum<"new">
  | enum<"learn">
  | enum<"review">
  | enum<"relearn">
  | enum<"cram">
}

fieldValueExpression[@dynamicPrecedence=3] {
  !unary Not?
  ( string | FieldValueEnum )
  ~x (Or? fieldValueExpression)*
}

FieldValueEnum[@dynamicPrecedence=1] {
    enum<"exists">
  | enum<"missing">
}

Group { "(" expression ")" }

stateIs { kw<"state"> Is }
kindIs  { kw<"kind">  Is }
fieldIs { kw<"field"> Is FieldName Is }

Label {
    "(" Not? stringLabels     stringExpression ")" | stringLabels Not? string
  | "(" Not?     idLabels         idExpression ")" |     idLabels Not? id
  | "(" Not?      stateIs  stateEnumExpression ")" |      stateIs Not? StateEnum
  | "(" Not?       kindIs   kindEnumExpression ")" |       kindIs Not? KindEnum
  | "(" Not?      fieldIs fieldValueExpression ")" |      fieldIs Not? ( string | FieldValueEnum )
  | due
  | repsLapses
  | createdUpdated
  | reviewed
}

string {
  Regex |
  ( SimpleString
  | QuotedString1
  | QuotedString2
  | Number
  | Html
  | RawStringLiteral
  | RawHtmlLiteral )
  Wildcard?
}

id { SimpleString | QuotedString1 | QuotedString2 | Number }

kw     <word> { @extend[@name={word}]<SimpleString, word> } // "keyword"
enum   <word> { @extend              <SimpleString, word> }
enumNum<word> { @extend              <Number      , word> }

stringLabels {
  ( noteCardIs? kw<"tag">
  | kw<"template">
  | kw<"setting">
  ) Is
}

FieldName {
  Not?
  (
    Regex |
    ( SimpleString | QuotedString1 | QuotedString2 | Number ) Wildcard?
  )
}

idLabels { 
  ( kw<"templateId">
  | kw<"cardId">
  | kw<"noteId">
  | kw<"settingId">
  ) Is
}

Or { @specialize<SimpleString, "OR"> | "," }

due {
  kw<"due">
  ( Is DueEnum
  | Is Not? Number
  | Comparison Date )
}

DueEnum { "true" | "false" }

createdUpdated {
  (
    ( kw<"note"> | kw<"card"> ) ":"
  ) ?
  ( kw<"created"> | kw<"edited"> )
  ( Is Not? Number
  | Comparison Date )
}

repsLapses {
  ( kw<"reps">
  | kw<"lapses">
  | noteCardIs?
    kw<"tag"> Is kw<"count"> )
  Comparison Number
}

noteCardIs {
  ( kw<"card"> | kw<"note"> ) ":"
}

reviewed {
  ( kw<"reviewed"> | kw<"firstReviewed"> )
  Comparison ( Not? Number | Date )
  ( Comparison RatingEnum ) ?
}

RatingEnum[@dynamicPrecedence=1] {
    enumNum<"1">
  | enumNum<"2">
  | enumNum<"3">
  | enumNum<"4">
  | enum<"again">
  | enum<"hard">
  | enum<"good">
  | enum<"easy">
}

Comparison { ":" | "=" | "<" | ">" | "<=" | ">=" }
Is { ":" | "=" }

@external tokens rawStringLiteral from "./query.tokens" {
  RawStringLiteral
}

@external tokens rawHtmlLiteral from "./query.tokens" {
  RawHtmlLiteral
}

@tokens {
  Wildcard { "*" }
  QuotedString1 { "'" char1* "'" }
  QuotedString2 { '"' char2* '"' }
  Html          { '`' charb* '`' }

  // https://github.com/lezer-parser/javascript/blob/392c6115647c9e55c147ac2d702f75be127a7b2d/src/javascript.grammar#L683
  // Not exactly the same because we're more interested in correctness (than tokenization) https://github.com/lezer-parser/javascript/pull/31#issuecomment-2016585616
  Regex[isolate] { "/" (![/\\\n[] | "\\" ![\n] | "[" (![\n\\\]] | "\\" ![\n])* "]")+ "/" $[dgimsuvy]* }

  // a char is any non-quote or non-backslash... or a backslash followed by a quote or backslash
  char1 {
         !['\\] |
    "\\" $['\\]
  }
  char2 {
         !["\\] |
    "\\" $["\\]
  }
  charb {
         ![`\\] |
    "\\" $[`\\]
  }
  // a SimpleString is any series of characters that is not equals, less than, greater than, backtick, backslash, forwardslash, asterisk, comma, parentheses, colon, quote, doublequote, or whitespace (as defined by the Unicode standard)
  SimpleString { ( ![=<>`\\/*,():'"\u0009\u000A\u000B\u000C\u000D\u0020\u0085\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000] )+ }
  whitespace { @whitespace+ }
  Number { @digit+ }
  Date { @digit @digit @digit @digit "-" @digit? @digit "-" @digit? @digit }

  Not { "-" }
  @precedence { Date, Number, Not, SimpleString }
}

@external propSource queryHighlighting from "./query.highlight.js"
