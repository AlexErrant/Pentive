@top Program { expression* }
@skip { whitespace }
@precedence { unary @right } // https://www.ibm.com/docs/en/i/7.5?topic=operators-operator-precedence-associativity

expression[@dynamicPrecedence=0] {
  !unary Not?
  (string | Group | Label)
  ~x (Or? expression)*
}

stringExpression[@dynamicPrecedence=1] {
  !unary Not?
  string
  ~x (Or? stringExpression)*
}

idExpression[@dynamicPrecedence=2] {
  !unary Not?
  id
  ~x (Or? idExpression)*
}

Group { "(" expression ")" }

Label {
  "(" Not? stringLabels stringExpression ")"
  | "(" Not?   idLabels     idExpression ")"
  | stringLabels Not? string
  |     idLabels Not? id
  | state
  | kind
  | due
  | repsLapses
  | createdUpdated
  | reviewed
}

string {
  Regex |
  ( SimpleString | QuotedString | Html ) Wildcard?
}

id { SimpleString | QuotedString }

// "keyword"
kw<word> { @specialize[@name={word}]<SimpleString, word> }

stringLabels { 
  ( kw<"tag">
  | kw<"template">
  | kw<"setting">
  | (kw<"field"> is FieldName)
  ) is
}

FieldName {
  Not? 
  ( 
    Regex |
    ( SimpleString | QuotedString ) Wildcard?
  )
}

idLabels { 
  ( kw<"templateId">
  | kw<"cardId">
  | kw<"noteId">
  | kw<"settingId">
  ) is
}

Or { @specialize<SimpleString, "OR"> | ","}

state {
  kw<"state"> is
  ( kw<"normal">
  | kw<"buried">
  | kw<"userBuried">
  | kw<"schedulerBuried">
  | kw<"suspended"> )
}

kind {
  kw<"kind"> is
  ( kw<"new">
  | kw<"learn">
  | kw<"review">
  | kw<"relearn">
  | kw<"cram"> )
}

due {
  kw<"due">
  ( is kw<"true">
  | is kw<"false">
  | is Number
  | Comparison Date )
}

createdUpdated {
  (
    ( kw<"note"> | kw<"card"> ) is
  ) ?
  ( kw<"created"> | kw<"edited"> )
  ( is Number
  | Comparison Date )
}

repsLapses {
  ( kw<"reps"> | kw<"lapses"> )
  Comparison Number
}

reviewed {
  ( kw<"reviewed"> | kw<"firstReviewed">)
  Comparison ( Number | Date )
  ( Comparison Number ) ?
}

Comparison { ":" | "=" | "<" | ">" | "<=" | ">=" }
is { ":" | "="}

@tokens {
  Wildcard { "*" }
  QuotedString { '"' char* '"' }
  Html         { '`' char* '`' }

  // https://github.com/lezer-parser/javascript/blob/392c6115647c9e55c147ac2d702f75be127a7b2d/src/javascript.grammar#L683
  // Not exactly the same because we're more interested in correctness (than tokenization) https://github.com/lezer-parser/javascript/pull/31#issuecomment-2016585616
  Regex[isolate] { "/" (![/\\\n[] | "\\" ![\n] | "[" (![\n\\\]] | "\\" ![\n])* "]")+ "/" $[dgimsuvy]* }

  // a char is any non-doublequote or non-backslash... or a backslash followed by a doublequote or backslash
  char {
         !["\\] |
    "\\" $["\\]
  }
  // a SimpleString is any series of characters that is not equals, less than, greater than, backtick, backslash, forwardslash, asterisk, comma, parentheses, colon, doublequote, or whitespace (as defined by the Unicode standard)
  SimpleString { ( ![=<>`\\/*,():"\u0009\u000A\u000B\u000C\u000D\u0020\u0085\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000] )+ }
  whitespace { @whitespace+ }
  Number { Not? @digit+ }
  Date { @digit @digit @digit @digit "-" @digit? @digit "-" @digit? @digit }

  Not { "-" }
  @precedence { Date, Number, Not, SimpleString }
}

@external propSource queryHighlighting from "./query.highlight.js"
