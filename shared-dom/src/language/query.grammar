@top Program { expression* }
@skip { whitespace }
@precedence { unary @right } // https://www.ibm.com/docs/en/i/7.5?topic=operators-operator-precedence-associativity

expression[@dynamicPrecedence=0] {
  !unary Not?
  (string | Group | Label)
  ~x (Or? expression)*
}

stringExpression[@dynamicPrecedence=1] {
  !unary Not?
  string
  ~x (Or? stringExpression)*
}

idExpression[@dynamicPrecedence=2] {
  !unary Not?
  id
  ~x (Or? idExpression)*
}

stateEnumExpression[@dynamicPrecedence=3] {
  !unary Not?
  StateEnum
  ~x (Or? stateEnumExpression)*
}

kindEnumExpression[@dynamicPrecedence=3] {
  !unary Not?
  KindEnum
  ~x (Or? kindEnumExpression)*
}

fieldValueExpression[@dynamicPrecedence=3] {
  !unary Not?
  ( string | FieldValueEnum )
  ~x (Or? fieldValueExpression)*
}

Group { "(" expression ")" }

stateIs { kw<"state"> Is }
kindIs  { kw<"kind">  Is }
fieldIs { kw<"field"> Is FieldName Is }

Label {
    "(" Not? stringLabels     stringExpression ")" | stringLabels Not? string
  | "(" Not?     idLabels         idExpression ")" |     idLabels Not? id
  | "(" Not?      stateIs  stateEnumExpression ")" |      stateIs Not? StateEnum
  | "(" Not?       kindIs   kindEnumExpression ")" |       kindIs Not? KindEnum
  | "(" Not?      fieldIs fieldValueExpression ")" |      fieldIs Not? ( string | FieldValueEnum )
  | due
  | repsLapses
  | createdUpdated
  | reviewed
}

string {
  Regex |
  ( SimpleString | QuotedString | Number | Html | RawStringLiteral | RawHtmlLiteral ) Wildcard?
}

id { SimpleString | QuotedString | Number }

// "keyword"
kw<word> { @specialize[@name={word}]<SimpleString, word> }

stringLabels {
  ( noteCardIs? kw<"tag">
  | kw<"template">
  | kw<"setting">
  ) Is
}

FieldName {
  Not?
  (
    Regex |
    ( SimpleString | QuotedString | Number ) Wildcard?
  )
}

idLabels { 
  ( kw<"templateId">
  | kw<"cardId">
  | kw<"noteId">
  | kw<"settingId">
  ) Is
}

Or { @specialize<SimpleString, "OR"> | ","}

due {
  kw<"due">
  ( Is DueEnum
  | Is Not? Number
  | Comparison Date )
}

DueEnum { "true" | "false" }

createdUpdated {
  (
    ( kw<"note"> | kw<"card"> ) ":"
  ) ?
  ( kw<"created"> | kw<"edited"> )
  ( Is Not? Number
  | Comparison Date )
}

repsLapses {
  ( kw<"reps">
  | kw<"lapses">
  | noteCardIs?
    kw<"tag"> Is kw<"count"> )
  Comparison Number
}

noteCardIs {
  ( kw<"card"> | kw<"note"> ) ":"
}

reviewed {
  ( kw<"reviewed"> | kw<"firstReviewed"> )
  Comparison ( Not? Number | Date )
  ( Comparison RatingEnum ) ?
}

Comparison { ":" | "=" | "<" | ">" | "<=" | ">=" }
Is { ":" | "=" }

@external tokens kindEnum from "./query.tokens" {
  KindEnum
}

@external tokens stateEnum from "./query.tokens" {
  StateEnum
}

@external tokens ratingEnum from "./query.tokens" {
  RatingEnum
}

@external tokens fieldValueEnum from "./query.tokens" {
  FieldValueEnum
}

@external tokens rawStringLiteral from "./query.tokens" {
  RawStringLiteral
}

@external tokens rawHtmlLiteral from "./query.tokens" {
  RawHtmlLiteral
}

@tokens {
  Wildcard { "*" }
  QuotedString { '"' char* '"' }
  Html         { '`' char* '`' }

  // https://github.com/lezer-parser/javascript/blob/392c6115647c9e55c147ac2d702f75be127a7b2d/src/javascript.grammar#L683
  // Not exactly the same because we're more interested in correctness (than tokenization) https://github.com/lezer-parser/javascript/pull/31#issuecomment-2016585616
  Regex[isolate] { "/" (![/\\\n[] | "\\" ![\n] | "[" (![\n\\\]] | "\\" ![\n])* "]")+ "/" $[dgimsuvy]* }

  // a char is any non-doublequote or non-backslash... or a backslash followed by a doublequote or backslash
  char {
         !["\\] |
    "\\" $["\\]
  }
  // a SimpleString is any series of characters that is not equals, less than, greater than, backtick, backslash, forwardslash, asterisk, comma, parentheses, colon, doublequote, or whitespace (as defined by the Unicode standard)
  SimpleString { ( ![=<>`\\/*,():"\u0009\u000A\u000B\u000C\u000D\u0020\u0085\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000] )+ }
  whitespace { @whitespace+ }
  Number { @digit+ }
  Date { @digit @digit @digit @digit "-" @digit? @digit "-" @digit? @digit }

  Not { "-" }
  @precedence { Date, Number, Not, SimpleString }
}

@external propSource queryHighlighting from "./query.highlight.js"
